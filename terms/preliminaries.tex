% !TeX spellcheck = en_GB
% !TeX encoding = UTF-8

\section{Preliminaries}
\label{sec:terms:prelim}

Throughout this chapter, the concept of \emph{mappings}\index{mapping} is pervasive.
I use the type notation $\alpha \holmap \beta$\index{$\rightharpoonup$@$\rightharpoonup$ (symbol)} to denote a function $\alpha \Rightarrow \beta\;\holtype{option}$ with a finite domain.
In certain contexts, a mapping may also be called an \keyword{environment}.

Mapping literals are written using brackets: $[a \mapsto x, b \mapsto y, \ldots]$.
If it is clear from the context that $\sigma$ is defined on $a$, the lookup $\sigma\;a$ can be treated as returning a value of type $\beta$.
The pair $(a, b)$ is also called an \keyword{entry} of the mapping.
A mapping can be constructed from a list or set of entries with the function \holconst{map\_of}\holconstindex{map\_of}.

The functions $\holtypejudgement{\holconst{dom}}{(\alpha \holmap \beta) \Rightarrow \alpha\;\holtype{set}}$\holconstindex{dom} and $\holtypejudgement{\holconst{range}}{(\alpha \holmap \beta) \Rightarrow \beta\;\holtype{set}}$\holconstindex{range} return the \keyword{domain} and \keyword{range} of a mapping, respectively.
In this context, \emph{domain} refers to the set of all keys in a mapping and is not to be confused with the domain of a function (§\ref{sec:preproc:dict:partial}).

Dropping entries from a mapping is denoted by $\sigma - k$, where $\sigma$ is a mapping and $k$ is either a single key or a set of keys.
I use $\sigma' \subseteq \sigma$ to denote that $\sigma'$ is a sub-mapping of $\sigma$, that is, the set of entries of $\sigma'$ is a subset of the set of entries of $\sigma$;
formally: $\holconst{dom}\;\sigma' \subseteq \holconst{dom}\;\sigma$ and $\forall a \in \holconst{dom}\;\sigma'.\; \sigma'\;a = \sigma\;a$.

Adding two mappings $\sigma$ and $\rho$ is denoted with $\envadd\sigma\rho$.
It constructs a new mapping with the union domain of $\sigma$ and $\rho$.
Entries from $\rho$ override entries from $\sigma$.
That is, $\rho \subseteq \envadd\sigma\rho$ holds, but not necessarily $\sigma \subseteq \envadd\sigma\rho$.

All mappings and sets are assumed to be finite.
In the formalization, this is enforced by using subtypes of $\holmap$ and \holtype{set}.%
\thyrefdist{HOL-Library}{Finite_Map}
In fact, nesting recursion through $\holmap$ and \holtype{set} would be unsound~\cite{gunter1992datatype,berghofer1999inductive,biendarra2017foundational}.
I leverage facilities of Blanchette \etal's \holcommand{datatype} command to construct the various term types~\cite{blanchette2014datatypes}.

The term \keyword{abstraction}, when used in the context of terms, refers to a $\lambda$-abstraction.
An abstraction -- in general of the form $\lambda x.\;t$ -- \emph{binds} a variable $x$ in $t$.
Variables that are not \emph{bound} are \emph{free}\index{variable, bound}\index{variable, free}.

\subsection{Names}
Constant and variable names are modelled as \holtype{string}s.
The full flexibility of that type (i.e.\ string manipulations) is only required where fresh names are being produced (§\ref{sec:intermediate:named:fresh}).

Otherwise, only a linear order on terms is needed, which in turn needs a linear order on names.
Conveniently, Sternagel and Thiemann \cite{sternagel2015deriving} provide tooling to automatically generate such a lexicographic order on types generated by the \holcommand{datatype} package.
It requires existing orderings for all constituent types of a datatype.

In Isabelle, \holtype{string} is a synonym for $\holtype{char}\;\holtype{list}$; i.e., a list of characters.
However, there is no default order on lists, as there could be multiple reasonable implementations: e.g.\ lexicographic and point-wise.
For both choices, users can import the corresponding instantiation.
In Isabelle, only at most one implementation of a given type class for a given type may be present in the same theory.
Consequently, I avoided importing a list ordering from the library, because it may cause conflicts with users who use another ordering.

The general approach for these situations is to introduce a type copy.
I have created a \holtype{name} type that wraps \holtype{string}s and requires no other instances to work.
For simplicity, I will use just \holtype{string} in this thesis.
The ordering on names is a copy of the lexicographic order on lists.

\subsection{Common functions}
All type constructors used in this formalization ($\holmap$, \holtype{set}, \holtype{list}, \holconst{option}, ...) support the common operations \holconst{map}\holconstindex{map} and \holconst{rel}\holconstindex{rel}.
For a type constructor $\tau$ with a single type variables $\alpha$, these two functions have the following types:
%
\begin{align*}
  \holtypejudgement{\holconst{map}_\tau}{&(\alpha \Rightarrow \beta) \Rightarrow \alpha\;\tau \Rightarrow \beta\;\tau} \\
  \holtypejudgement{\holconst{rel}_\tau}{&(\alpha \Rightarrow \beta \Rightarrow \holtype{bool}) \Rightarrow \alpha\;\tau \Rightarrow  \beta\;\tau \Rightarrow \holtype{bool}}\\
\end{align*}
%
If the type constructor is obvious from the context, it is omitted.

For parametrized datatypes like lists, $\holconst{map}_\tau$ is the usual functorial map.
The intuition behind $\holconst{rel}_\tau$ is to lift a binary predicate $\holtypejudgement{P}{\alpha \Rightarrow \beta \Rightarrow \holtype{bool}}$ to the type constructor $\tau$.
This lifted relation is the \keyword{relator} for a particular type.
Its definition is structural, based on the constructors:\index{rellist@$\holconst{rel}_{\holtype{list}}$ (definition)}
%
\[
  \inferrule*{
  }{\holconst{rel}_{\holtype{list}}\;P\;[]\;[]} \qquad
  \inferrule*{
    \holconst{rel}_{\holtype{list}}\;P\;\mathit{xs}\;\mathit{ys} \\
    P\;x\;y
  }{\holconst{rel}_{\holtype{list}}\;P\;(x \cons xs)\;(y \cons ys)}
\]

For other types, the situation is a bit more complicated.
The types of $\holconst{map}_{\holtype{set}}$ and $\holconst{rel}_{\holtype{set}}$ are as expected.
Mapping a set applies a function to all elements; an operation usually known as image of a function under a set.

\begin{definition}[Set relator]\index{rellist@$\holconst{rel}_{\holtype{set}}$ (definition)}
  For each element $a \in A$, there must be a corresponding element $b \in B$ such that $P\;a\;b$, and vice versa. Formally:
  \[ \holconst{rel}_{\holtype{set}}\;P\;A\;B \biimplies (\forall x \in A.\; \exists y \in B.\; P\;x\;y) \wedge (\forall y \in B.\; \exists x \in A.\; P\;x\;y) \]
\end{definition}

\noindent
Finally, consider mappings.
The map function has the type $(\beta \Rightarrow \gamma) \Rightarrow (\alpha \holmap \beta) \Rightarrow (\alpha \holmap \gamma)$.
It leaves the domain unchanged, but applies a function to the range of the mapping.
In other words, the keys do not participate in this operation.

\begin{definition}[Mapping relator]\index{rellist@$\holconst{rel}_{\holtype{map}}$ (definition)}
  Two maps $m_1$ and $m_2$ are related with respect to $P$ if for all values $k$:
    \[ \holconst{rel}_{\holtype{option}}\;P\;(m_1\;k)\;(m_2\;k) \]
\end{definition}

\begin{corollary}
  Related maps share a common domain.
  Formally:
  \[ \holconst{rel}_{\holmap}\;m\;n \implies \holconst{dom}\;m = \holconst{dom}\;n \]
\end{corollary}

\subsection{Modularity}
\label{sec:terms:prelim:modularity}

The formalization relies on two of Isabelle's modularization concepts: \emph{classes} and \emph{locales}~\cite{ballarin2018locales}\index{locale}.
Both of them represent named contexts:
they can be used to bundle one or more types together with operations and their properties.

Classes are briefly introduced in §\ref{sec:preproc:dict:prelim}, in the context of the dictionary construction.
Here, I will focus on them as a mechanism to organize a formalization abstractly.

\begin{code}[t]
  \begin{lstlisting}
locale simple_syntactic_and =
  fixes //P// :: $\alpha$::term $\Rightarrow$ bool
  assumes P_app: //P// (app //t// //u//) = //P// //t// $\wedge$ //P// //u//
begin

  lemma list_comb: //P// (list_comb //f// //xs//) = //P// //f// $\wedge$ list_all //P// //xs//
  (* proof *)

end

interpretation no_abs: simple_syntactic_and no_abs
(* proof *)
  \end{lstlisting}
  \caption{Example locale}
  \label{code:terms:preproc:locale}
\end{code}

Locales are a generalization of that concept.
They allow arbitrarily many fixed types and support more complex inheritance relationships.
In the formalization, this is used extensively to avoid duplication.

An example locale is shown in \cref{code:terms:preproc:locale}.
It introduces the locale \holconst{simple\_syntactic\_and} (§\ref{sec:terms:algebra:thy:preds}) that fixes a variable and assumes a property.
In the body (Isabelle parlance: \emph{locale context}), a lemma is stated; the proof may refer to the locale assumptions.
Finally, the locale is \emph{interpreted}\index{locale interpretation}, i.e., the variables instantiated and assumptions proved.

Interpretations may occur at various places in Isabelle theories.
Notably, they can appear in other locale contexts; then, they are called \keyword{sublocale} interpretations.
Sublocales do not suffer from the same restriction as subclasses: parameters can be instantiated freely and need not be shared.

\subsection{Monad syntax}
\label{sec:terms:prelim:monad}
Many operations on terms are partial, i.e., they are not specified on some inputs.
To avoid carrying around too many constraints, I have decided to model some as returning \holtype{option}s.
As a notational convenience, Isabelle provides \emph{monad syntax} that is similar to Haskell's \holkeyword{do} notation \cite[§3.14]{marlow2010haskell}.%
\thyrefdist{HOL-Library}{Monad_Syntax}

In the case of the \holtype{option} type constructor, the expression $\holkeyword{do} \;\{ x \leftarrow f;\; g \;x \}$ is desugared to $\holconst{bind}_{\holtype{option}}\;f\;(\lambda x.\;g\;x)$, where \holconst{bind}\holconstindex{bind} is defined as follows:
\begin{lstlisting}[language=Isabelle]
fun bind :: $\alpha$ option $\Rightarrow$ ($\alpha$ $\Rightarrow$ $\beta$ option) $\Rightarrow$ $\beta$ option
bind None //f// = None
bind (Some //x//) //f// = //f// //x//
\end{lstlisting}
%
The desugaring process is iterated until all statements in the $\holkeyword{do}$ block are replaced by \holconst{bind}.

In other words, a \holkeyword{do} block can be interpreted as a series of \holkeyword{let} expressions that ``short-circuit'' the expression to \holconst{None} if any of the statements evaluates to \holconst{None}.

The monad syntax also allows monads other than \holtype{option}.
In this chapter, only \holtype{option} is used; this choice will be revisited in §\ref{sec:intermediate:named}.